//! src/lib.rs
//!
//! @description
//! This is the main entry point for the Aces Unknown on-chain program.
//! It defines the program's instructions, state accounts, and custom errors.
//! The program orchestrates the public aspects of the poker game on Solana,
//! such as managing tables and player actions, while delegating all confidential
//! logic (card shuffling, dealing, showdowns) to the Arcium network.
//!
//! The program is built using the Anchor framework for Solana and the Arcis
//! framework for confidential computations on Arcium.

use anchor_lang::prelude::*;
use arcium_anchor::prelude::*;
// SIGN_PDA_SEED imported from prelude above

// Import local modules.
pub mod state;
pub mod error;
pub mod instructions;

// Make their contents available for the program.
use state::*;
use instructions::*;

// Callback structs are handled by the #[arcium_callback] macros

// Arcium Encrypted Data Types (these will be generated by macros)

// Arcium Computation Definition Offsets
// These constants are unique identifiers for each confidential instruction.
const COMP_DEF_OFFSET_SHUFFLE_AND_DEAL: u32 = comp_def_offset("shuffle_and_deal");
const COMP_DEF_OFFSET_REVEAL_COMMUNITY_CARDS: u32 = comp_def_offset("reveal_community_cards");
const COMP_DEF_OFFSET_EVALUATE_HANDS_AND_PAYOUT: u32 = comp_def_offset("evaluate_hands_and_payout");

// Program ID
declare_id!("4ir9eYNjfVJggq19Su6DzAD4e24Yi4THesJjpBbAonVV");

#[arcium_program]
pub mod aces_unknown {
    use super::*;

    // ========================================
    // Arcium Computation Definition Initialization
    // ========================================

    /// Initialize the shuffle_and_deal computation definition
    pub fn init_shuffle_and_deal_comp_def(ctx: Context<InitShuffleAndDealCompDef>) -> Result<()> {
        // TODO: Replace with proper Arcium init when tools are working correctly
        // init_comp_def(ctx.accounts, true, 0, None, None)?;
        // For now, just return success
        Ok(())
    }

    /// Initialize the reveal_community_cards computation definition
    pub fn init_reveal_community_cards_comp_def(ctx: Context<InitRevealCommunityCardsCompDef>) -> Result<()> {
        // TODO: Replace with proper Arcium init when tools are working correctly
        // init_comp_def(ctx.accounts, true, 0, None, None)?;
        // For now, just return success
        Ok(())
    }

    /// Initialize the evaluate_hands_and_payout computation definition
    pub fn init_evaluate_hands_and_payout_comp_def(ctx: Context<InitEvaluateHandsAndPayoutCompDef>) -> Result<()> {
        // TODO: Replace with proper Arcium init when tools are working correctly
        // init_comp_def(ctx.accounts, true, 0, None, None)?;
        // For now, just return success
        Ok(())
    }

    // ========================================
    // Arcium Computation Invocations
    // ========================================

    /// Queue a shuffle and deal computation (called by start_hand)
    pub fn shuffle_and_deal(
        ctx: Context<ShuffleAndDeal>,
        computation_offset: u64,
    ) -> Result<()> {
        // Simplified computation queuing for compilation
        // TODO: Replace with proper Arcium computation queuing
        // For now, just return success
        Ok(())
    }

    /// Queue a reveal community cards computation (called by deal_community_cards)
    pub fn reveal_community_cards(
        ctx: Context<RevealCommunityCards>,
        computation_offset: u64,
        num_cards: u8,
    ) -> Result<()> {
        // Simplified computation queuing for compilation
        // TODO: Replace with proper Arcium computation queuing
        // For now, just return success
        Ok(())
    }

    /// Queue an evaluate hands and payout computation (called by resolve_showdown)
    pub fn evaluate_hands_and_payout(
        ctx: Context<EvaluateHandsAndPayout>,
        computation_offset: u64,
    ) -> Result<()> {
        // Simplified computation queuing for compilation
        // TODO: Replace with proper Arcium computation queuing
        // For now, just return success
        Ok(())
    }

    // ========================================
    // Arcium Callbacks
    // ========================================

    /// Callback for shuffle_and_deal computation result
    // TODO: Uncomment when Arcium macros are working correctly
    // #[arcium_callback(encrypted_ix = "shuffle_and_deal")]
    // pub fn shuffle_and_deal_callback(
    //     ctx: Context<ShuffleAndDealCallback>,
    //     output: ComputationOutputs<ShuffleAndDealOutput>,
    // ) -> Result<()> {
    //     let _result = match output {
    //         ComputationOutputs::Success(data) => data,
    //         _ => return Err(error::AcesUnknownErrorCode::AbortedComputation.into()),
    //     };
    //     emit!(HandShuffled { table_id: ctx.accounts.table.table_id });
    //     Ok(())
    // }

    /// Simplified callback for shuffle_and_deal computation result
    pub fn shuffle_and_deal_callback(ctx: Context<ShuffleAndDealCallback>) -> Result<()> {
        emit!(HandShuffled { table_id: ctx.accounts.table.table_id });
        Ok(())
    }

    /// Callback for reveal_community_cards computation result
    // TODO: Uncomment when Arcium macros are working correctly
    // #[arcium_callback(encrypted_ix = "reveal_community_cards")]
    // pub fn reveal_community_cards_callback(
    //     ctx: Context<RevealCommunityCardsCallback>,
    //     output: ComputationOutputs<RevealCommunityCardsOutput>,
    // ) -> Result<()> {
    //     let _result = match output {
    //         ComputationOutputs::Success(data) => data,
    //         _ => return Err(error::AcesUnknownErrorCode::AbortedComputation.into()),
    //     };
    //     emit!(CommunityCardsDealt {
    //         table_id: ctx.accounts.table.table_id,
    //         hand_id: ctx.accounts.hand_data.hand_id,
    //         cards: ctx.accounts.table.community_cards,
    //     });
    //     Ok(())
    // }

    /// Simplified callback for reveal_community_cards computation result
    pub fn reveal_community_cards_callback(ctx: Context<RevealCommunityCardsCallback>) -> Result<()> {
        emit!(CommunityCardsDealt {
            table_id: ctx.accounts.table.table_id,
            hand_id: ctx.accounts.hand_data.hand_id,
            cards: ctx.accounts.table.community_cards,
        });
        Ok(())
    }

    /// Callback for evaluate_hands_and_payout computation result
    // TODO: Uncomment when Arcium macros are working correctly
    // #[arcium_callback(encrypted_ix = "evaluate_hands_and_payout")]
    // pub fn evaluate_hands_and_payout_callback(
    //     ctx: Context<EvaluateHandsAndPayoutCallback>,
    //     output: ComputationOutputs<EvaluateHandsAndPayoutOutput>,
    // ) -> Result<()> {
    //     let _result = match output {
    //         ComputationOutputs::Success(data) => data,
    //         _ => return Err(error::AcesUnknownErrorCode::AbortedComputation.into()),
    //     };
    //     emit!(HandResolved {
    //         table_id: ctx.accounts.table.table_id,
    //         hand_id: ctx.accounts.hand_data.hand_id,
    //         pot: ctx.accounts.table.pot,
    //         rake: 0, // Calculate rake amount
    //     });
    //     Ok(())
    // }

    /// Simplified callback for evaluate_hands_and_payout computation result
    pub fn evaluate_hands_and_payout_callback(ctx: Context<EvaluateHandsAndPayoutCallback>) -> Result<()> {
        emit!(HandResolved {
            table_id: ctx.accounts.table.table_id,
            hand_id: ctx.accounts.hand_data.hand_id,
            pot: ctx.accounts.table.pot,
            rake: 0, // Calculate rake amount
        });
        Ok(())
    }

    // ========================================
    // Admin & Table Management Instructions
    // ========================================

    /// Initializes a `PlatformConfig` singleton account with the deployer as the admin.
    /// This should be called once after the program is deployed.
    pub fn initialize_platform_config(ctx: Context<InitializePlatformConfig>) -> Result<()> {
        ctx.accounts.platform_config.admin = ctx.accounts.admin.key();
        ctx.accounts.platform_config.rake_bps = 500; // Default 5.00%
        ctx.accounts.platform_config.rake_max_cap = 0; // Default no cap
        ctx.accounts.platform_config.treasury_vault = ctx.accounts.treasury_vault.key();
        Ok(())
    }

    /// Instruction for the platform admin to update rake parameters.
    pub fn update_rake_params(
        ctx: Context<UpdateRakeParams>,
        new_rake_bps: u16,
        new_rake_max_cap: u64,
    ) -> Result<()> {
        instructions::update_rake_params::update_rake_params(ctx, new_rake_bps, new_rake_max_cap)
    }

    /// Instruction for a player to create a new poker table.
    pub fn create_table(
        ctx: Context<CreateTable>,
        table_id: u64,
        small_blind: u64,
        big_blind: u64,
        buy_in: u64,
    ) -> Result<()> {
        instructions::create_table::create_table(ctx, table_id, small_blind, big_blind, buy_in)
    }

    /// Instruction for a player to join an existing table.
    pub fn join_table(ctx: Context<JoinTable>, table_id: u64, seat_index: u8, buy_in: u64) -> Result<()> {
        instructions::join_table::join_table(ctx, table_id, seat_index, buy_in)
    }

    /// Instruction for a player to leave a table and cash out their chips.
    pub fn leave_table(ctx: Context<LeaveTable>, table_id: u64) -> Result<()> {
        instructions::leave_table::leave_table(ctx, table_id)
    }

    // ========================================
    // Hand Lifecycle Instructions
    // ========================================

    /// Starts a new hand, collects blinds, and queues the shuffle/deal computation.
    pub fn start_hand(ctx: Context<StartHand>, table_id: u64) -> Result<()> {
        instructions::start_hand::start_hand(ctx, table_id)
    }

    /// Reveals the next community cards (flop, turn, or river).
    pub fn deal_community_cards(ctx: Context<DealCommunityCards>, table_id: u64) -> Result<()> {
        instructions::deal_community_cards::deal_community_cards(ctx, table_id)
    }

    /// Resolves the showdown, determines the winner, and handles payouts.
    pub fn resolve_showdown(ctx: Context<ResolveShowdown>, table_id: u64) -> Result<()> {
        instructions::resolve_showdown::resolve_showdown(ctx, table_id)
    }
    
    // ========================================
    // Player Action & Timeout Instructions
    // ========================================
    
    /// The main instruction for a player to take an action (fold, check, call, bet, raise).
    pub fn player_action(ctx: Context<PlayerActionAccounts>, table_id: u64, action: crate::state::PlayerAction) -> Result<()> {
        instructions::player_action::player_action(ctx, table_id, action)
    }

    /// Instruction for anyone to fold a player whose turn timer has expired.
    pub fn force_player_fold(ctx: Context<ForcePlayerFold>, table_id: u64) -> Result<()> {
        instructions::force_player_fold::force_player_fold(ctx, table_id)
    }

    /// Safety instruction to refund all bets if a hand becomes unrecoverably stuck.
    pub fn force_hand_refund(ctx: Context<ForceHandRefund>, table_id: u64) -> Result<()> {
        instructions::force_hand_refund::force_hand_refund(ctx, table_id)
    }

    // ========================================
    // Arcium Callbacks (placeholders - to be implemented when Arcium integration is properly set up)
    // ========================================
}



/// Context for initializing the `PlatformConfig` account.
#[derive(Accounts)]
pub struct InitializePlatformConfig<'info> {
    #[account(
        init,
        payer = admin,
        space = 8 + PlatformConfig::INIT_SPACE,
        seeds = [b"platform_config"],
        bump
    )]
    pub platform_config: Account<'info, PlatformConfig>,
    #[account(mut)]
    pub admin: Signer<'info>,
    /// CHECK: Treasury vault account for platform rake collection
    pub treasury_vault: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
}

// ========================================
// Arcium Computation Definition Contexts (Simplified for Compatibility)
// TODO: Replace with proper Arcium macros when tools are working correctly
// ========================================

#[derive(Accounts)]
pub struct InitShuffleAndDealCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Computation definition account initialized by Arcium program
    #[account(mut)]
    pub comp_def_account: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct InitRevealCommunityCardsCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Computation definition account initialized by Arcium program
    #[account(mut)]
    pub comp_def_account: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct InitEvaluateHandsAndPayoutCompDef<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Computation definition account initialized by Arcium program
    #[account(mut)]
    pub comp_def_account: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
}

// ========================================
// Arcium Computation Contexts (Simplified for Compatibility)
// TODO: Replace with proper Arcium macros when tools are working correctly
// ========================================

#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct ShuffleAndDeal<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Computation account created by Arcium program
    #[account(mut)]
    pub computation_account: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
    // Hand-specific accounts
    #[account(mut)]
    pub hand_data: Account<'info, HandData>,
}

#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct RevealCommunityCards<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Computation account created by Arcium program
    #[account(mut)]
    pub computation_account: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
    // Hand-specific accounts
    #[account(mut)]
    pub hand_data: Account<'info, HandData>,
}

#[derive(Accounts)]
#[instruction(computation_offset: u64)]
pub struct EvaluateHandsAndPayout<'info> {
    #[account(mut)]
    pub payer: Signer<'info>,
    /// CHECK: Computation account created by Arcium program
    #[account(mut)]
    pub computation_account: UncheckedAccount<'info>,
    pub system_program: Program<'info, System>,
    // Hand-specific accounts
    #[account(mut)]
    pub hand_data: Account<'info, HandData>,
}

// ========================================
// Arcium Callback Contexts (Simplified for Compatibility)
// TODO: Replace with proper Arcium macros when tools are working correctly
// ========================================

#[derive(Accounts)]
pub struct ShuffleAndDealCallback<'info> {
    // Hand data account to update
    #[account(mut)]
    pub hand_data: Account<'info, HandData>,
    // Table account for reference
    #[account(mut)]
    pub table: Account<'info, Table>,
}

#[derive(Accounts)]
pub struct RevealCommunityCardsCallback<'info> {
    // Hand data account to update
    #[account(mut)]
    pub hand_data: Account<'info, HandData>,
    // Table account to update with community cards
    #[account(mut)]
    pub table: Account<'info, Table>,
}

#[derive(Accounts)]
pub struct EvaluateHandsAndPayoutCallback<'info> {
    // Hand data account
    #[account(mut)]
    pub hand_data: Account<'info, HandData>,
    // Table account
    #[account(mut)]
    pub table: Account<'info, Table>,
    // Platform config for rake
    #[account(mut)]
    pub platform_config: Account<'info, PlatformConfig>,
    // Token accounts for payouts
    #[account(mut)]
    pub table_vault: Account<'info, anchor_spl::token::TokenAccount>,
    #[account(mut)]
    pub treasury_vault: Account<'info, anchor_spl::token::TokenAccount>,
    // Token program
    pub token_program: Program<'info, anchor_spl::token::Token>,
}

// ========================================
// Callback Account Structs (generated by macros)
// ========================================
